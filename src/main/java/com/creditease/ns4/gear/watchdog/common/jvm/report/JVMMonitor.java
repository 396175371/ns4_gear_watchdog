package com.creditease.ns4.gear.watchdog.common.jvm.report;import com.alibaba.fastjson.JSON;import com.creditease.ns4.gear.watchdog.common.ProcessUtil;import com.sun.management.OperatingSystemMXBean;import java.lang.management.ManagementFactory;import java.lang.management.ThreadMXBean;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;/** * @author 杨红岩 * @description JVM监控 * @date 2019/3/5 */public class JVMMonitor {    /**     * 获得监控数据     *///    public static String getData() {//        Map<String, Object> jvmMetric = new HashMap<String, Object>();//        jvmMetric.put("time", System.currentTimeMillis());//        jvmMetric.put("memory", MemoryReport.generate());//        jvmMetric.put("process", ProcessReport.generate());//        jvmMetric.put("threads", ThreadsReport.generate());//        return JSON.toJSONString(jvmMetric);//    }    private static OperatingSystemMXBean osmxb = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();    private static int availableProcessors = 0;    /**     * 获取cpu核心数     */    public static int getAvailableProcessors() {        if (availableProcessors == 0) {            availableProcessors = Runtime.getRuntime().availableProcessors();        }        return availableProcessors;    }    /**     * 获得监控数据     */    public static String getData() {        Map<String, Object> data = new HashMap<>(11);        // 虚拟机级内存情况查询        long vmFree = 0;        long vmUse = 0;        long vmTotal = 0;        long vmMax = 0;        int byteToMb = 1024 * 1024;        Runtime rt = Runtime.getRuntime();        vmTotal = rt.totalMemory() / byteToMb;        vmFree = rt.freeMemory() / byteToMb;        vmMax = rt.maxMemory() / byteToMb;        vmUse = vmTotal - vmFree;        long physicalFree = osmxb.getFreePhysicalMemorySize() / byteToMb;        long physicalTotal = osmxb.getTotalPhysicalMemorySize() / byteToMb;        long physicalUse = physicalTotal - physicalFree;        double systemCpuLoad = osmxb.getSystemCpuLoad();        double processCpuLoad = osmxb.getProcessCpuLoad();        BigDecimal cpu1 = new BigDecimal(systemCpuLoad);        cpu1 = cpu1.multiply(new BigDecimal(100));        BigDecimal cpu2 = new BigDecimal(processCpuLoad);        cpu2 = cpu2.multiply(new BigDecimal(100));        data.put("pid", ProcessUtil.getProcessID());//进程PID        data.put("memUsedSpace", vmUse);//JVM内存已用的空间为        data.put("memFreeSpace", vmFree);//JVM内存的空闲空间为        data.put("memTotalSpace", vmTotal);//JVM总内存空间为        data.put("memMaxSpace", vmMax);//JVM最大空间为        data.put("physicalFree", physicalFree);//操作系统物理内存已用的空间为        data.put("physicalUse", physicalUse);//操作系统物理内存的空闲空间为        data.put("physicalTotal", physicalTotal);//操作系统总物理内存        data.put("systemCpuLoad", cpu1.setScale(2, BigDecimal.ROUND_DOWN).toString());//CPU总使用        data.put("processCpuLoad", cpu2.setScale(2, BigDecimal.ROUND_DOWN).toString());//进程使用CPU        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();        data.put("totalThread", threadMXBean.getThreadCount());//获得线程总数        return JSON.toJSONString(data);    }//    public static void main(String[] args) {//        // 虚拟机级内存情况查询//        long vmFree = 0;//        long vmUse = 0;//        long vmTotal = 0;//        long vmMax = 0;//        int byteToMb = 1024 * 1024;//        Runtime rt = Runtime.getRuntime();//        vmTotal = rt.totalMemory() / byteToMb;//        vmFree = rt.freeMemory() / byteToMb;//        vmMax = rt.maxMemory() / byteToMb;//        vmUse = vmTotal - vmFree;//        Map<String, Object> data = new HashMap<>();//        data.put("memUsedSpace", vmUse);//JVM内存已用的空间为//        data.put("memFreeSpace", vmFree);//JVM内存的空闲空间为//        data.put("memTotalSpace", vmTotal);//JVM总内存空间为//        data.put("memMaxSpace", vmMax);//JVM最大空间为//        long physicalFree = osmxb.getFreePhysicalMemorySize() / byteToMb;//        long physicalTotal = osmxb.getTotalPhysicalMemorySize() / byteToMb;//        long physicalUse = physicalTotal - physicalFree;//        data.put("physicalFree", physicalFree);//操作系统物理内存已用的空间为//        data.put("physicalUse", physicalUse);//操作系统物理内存的空闲空间为//        data.put("physicalTotal", physicalTotal);//操作系统总物理内存//        double systemCpuLoad = osmxb.getSystemCpuLoad();//        double processCpuLoad = osmxb.getProcessCpuLoad();//        data.put("physicalFree", systemCpuLoad);//CPU使用负载//        data.put("processCpuLoad", processCpuLoad);//线程使用负载//        // 获得线程总数//        ThreadGroup parentThread;//        int totalThread = 0;//        for (parentThread = Thread.currentThread().getThreadGroup(); parentThread//                .getParent() != null; parentThread = parentThread.getParent()) {//            totalThread = parentThread.activeCount();//        }//        data.put("totalThread", totalThread);//获得线程总数//        System.out.println("JVM内存已用的空间为：" + vmUse + " MB");//        System.out.println("JVM内存的空闲空间为：" + vmFree + " MB");//        System.out.println("JVM总内存空间为：" + vmTotal + " MB");//        System.out.println("JVM总内存空间为：" + vmMax + " MB");//        System.out.println("操作系统物理内存已用的空间为：" + physicalFree + " MB");//        System.out.println("操作系统物理内存的空闲空间为：" + physicalUse + " MB");//        System.out.println("操作系统总物理内存：" + physicalTotal + " MB");//        System.out.println("CPU使用负载：" + systemCpuLoad);//        System.out.println("线程使用负载：" + processCpuLoad);//        System.out.println("获得线程总数:" + totalThread);//    }}